[
  {
    "role": "user",
    "content": "Message from Space\nYou have received an encrypted message from space. Your task is to decrypt the message with the following simple rules:\n\nMessage string will consist of capital letters, numbers, and brackets only.\nWhen there's a block of code inside the brackets, such as [10AB], it means you need to repeat the letters AB for 10 times.\nMessage can be embedded in multiple layers of blocks.\nFinal decrypted message will only consist of capital letters.\nCreate a function that takes encrypted message str and returns the decrypted message.\n\nExamples\nspaceMessage(\"ABCD\") ➞ \"ABCD\"\n\nspaceMessage(\"AB[3CD]\") ➞ \"ABCDCDCD\"\n// \"AB\" = \"AB\"\n// \"[3CD]\" = \"CDCDCD\"\n\nspaceMessage(\"IF[2E]LG[5O]D\") ➞ \"IFEELGOOOOOD\"\n\nin C++"
  },
  {
    "role": "assistant",
    "content": "To solve this problem, we need to decrypt an encrypted message from space using specific rules. The message can contain capital letters, numbers, and brackets. The brackets indicate that the content inside should be repeated a certain number of times. The challenge is to handle nested brackets correctly.\n\n### Approach\n1. **Parsing the Message**: The message is processed character by character. When a bracket `[` is encountered, we need to parse the number immediately following it, which indicates how many times the subsequent content should be repeated.\n2. **Handling Nested Brackets**: The content inside the brackets can itself contain nested brackets. To handle this, we use a recursive approach. Each time we encounter a bracket, we parse its content recursively until we find the matching closing bracket `]`.\n3. **Tracking Bracket Balance**: To correctly identify the matching closing bracket for nested structures, we maintain a balance counter. This counter increments when encountering an opening bracket `[` and decrements when encountering a closing bracket `]`. When the balance reaches zero, we have found the matching closing bracket.\n4. **Recursive Decryption**: For each segment inside brackets, we recursively decrypt the content and then repeat it the specified number of times.\n\n### Solution Code\n```cpp\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring decrypt(const string& s) {\n    int pos = 0;\n    return helper(s, pos);\n}\n\nstring helper(const string& s, int& pos) {\n    string result;\n    while (pos < s.size()) {\n        if (s[pos] != '[') {\n            result += s[pos++];\n        } else {\n            // Skip the '['\n            ++pos;\n            // Parse the number\n            int num = 0;\n            while (pos < s.size() && isdigit(s[pos])) {\n                num = num * 10 + (s[pos] - '0');\n                ++pos;\n            }\n            // Parse the content until matching ']'\n            int balance = 1;\n            int contentStart = pos;\n            while (pos < s.size() && balance != 0) {\n                if (s[pos] == '[') {\n                    ++balance;\n                } else if (s[pos] == ']') {\n                    --balance;\n                }\n                ++pos;\n            }\n            // Extract the content substring\n            string content = s.substr(contentStart, pos - contentStart - 1);\n            // Recursively decrypt the content\n            string decryptedContent = helper(content, 0); // Start from position 0 for the content\n            // Append the decrypted content repeated 'num' times\n            for (int i = 0; i < num; ++i) {\n                result += decryptedContent;\n            }\n        }\n    }\n    return result;\n}\n```\n\n### Explanation\n1. **Main Function**: The `decrypt` function initializes the position counter and calls the helper function to start processing the message from the beginning.\n2. **Helper Function**: This function processes the message character by character. When a bracket is encountered, it parses the number and the content inside the brackets. The content is then recursively decrypted and repeated the specified number of times.\n3. **Bracket Balance**: The balance counter ensures that we correctly identify the matching closing bracket for nested structures, allowing us to extract the content accurately.\n4. **Recursion**: By recursively processing each segment inside brackets, we handle nested structures efficiently. Each level of recursion processes its own segment and returns the decrypted content, which is then repeated as specified.\n\nThis approach ensures that all layers of nested brackets are handled correctly, and the final decrypted message consists only of capital letters as required."
  }
]