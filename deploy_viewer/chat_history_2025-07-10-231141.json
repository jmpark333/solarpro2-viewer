[
  {
    "role": "user",
    "content": "Longest Alternating Substring\nGiven a string of digits, return the longest substring with alternating odd/even or even/odd digits. If two or more substrings have the same length, return the substring that occurs first.\n\nExamples\nlongest_substring(\"225424272163254474441338664823\") ➞ \"272163254\"\n# substrings = 254, 272163254, 474, 41, 38, 23\n\nlongest_substring(\"594127169973391692147228678476\") ➞ \"16921472\"\n# substrings = 94127, 169, 16921472, 678, 476\n\nlongest_substring(\"721449827599186159274227324466\") ➞ \"7214\"\n# substrings = 7214, 498, 27, 18, 61, 9274, 27, 32\n# 7214 and 9274 have same length, but 7214 occurs first.\nNotes\nThe minimum alternating substring size is 2, and there will always be at least one alternating substring.\n\nin Python"
  },
  {
    "role": "assistant",
    "content": "To solve this problem, we need to find the longest alternating substring in a given string of digits. An alternating substring is defined as a sequence where each consecutive digit alternates between odd and even. If there are multiple substrings of the same maximum length, we return the one that occurs first.\n\n### Approach\n1. **Initialization**: Start by initializing variables to keep track of the maximum length found (`max_len`), the starting index of this maximum substring (`max_start`), and the starting index of the current substring being evaluated (`current_start`).\n2. **Iterate through the String**: Loop through the string starting from the second character. For each character, check if it alternates with the previous character (one is even, the other is odd).\n3. **Update Current Substring**: If the current character does not alternate with the previous one, calculate the length of the current substring. If this length is at least 2 (the minimum valid length), update the maximum length and starting index if this substring is longer than the previously found maximum.\n4. **Handle Remaining Substring**: After the loop, check the substring from the last recorded starting index to the end of the string to ensure it is considered.\n5. **Return Result**: Extract and return the substring using the recorded maximum length and starting index.\n\n### Solution Code\n```python\ndef longest_substring(s):\n    if len(s) < 2:\n        return \"\"\n    \n    max_len = 0\n    max_start = 0\n    current_start = 0\n    n = len(s)\n    \n    for i in range(1, n):\n        prev = int(s[i-1])\n        curr = int(s[i])\n        if (prev % 2) != (curr % 2):\n            continue\n        else:\n            current_length = i - current_start\n            if current_length >= 2:\n                if current_length > max_len:\n                    max_len = current_length\n                    max_start = current_start\n            current_start = i\n    \n    # Check the last substring\n    current_length = n - current_start\n    if current_length >= 2:\n        if current_length > max_len:\n            max_len = current_length\n            max_start = current_start\n        # If equal, do nothing as we keep the first occurrence\n    \n    return s[max_start : max_start + max_len]\n\n# Test cases\nprint(longest_substring(\"225424272163254474441338664823\"))  # \"272163254\"\nprint(longest_substring(\"594127169973391692147228678476\"))  # \"16921472\"\nprint(longest_substring(\"721449827599186159274227324466\"))  # \"7214\"\n```\n\n### Explanation\n- **Initialization**: We start with `max_len` and `max_start` set to 0, and `current_start` also set to 0 to track the beginning of the current valid substring.\n- **Loop Through String**: For each character, we check if it alternates with the previous character. If it does not, we calculate the length of the current substring and update our maximum if necessary.\n- **Edge Case Handling**: After the loop, we check the substring from the last `current_start` to the end of the string to ensure we do not miss the longest substring at the end.\n- **Efficiency**: The algorithm runs in O(n) time where n is the length of the string, as each character is checked exactly once. This ensures the solution is efficient even for longer strings."
  }
]